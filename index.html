<!DOCTYPE html>
<html lang="de-ch">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Lerndokumentation SQL</title>
    <link rel="stylesheet" href="style.css" type="text/css">
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
</head>



<body>
    <header>
        <div id="titel">
            <a href="#titel"><img id="titelbild" src="bilder/home.png" alt="home" id="home"></a>
            <h1 id="titelh1">Lerndokumentationen</h1>
        </div>
        <nav id="nav">
            <ul id="liststyle">
                <div class="hovernav">
                    <li><a href="index.html">SQL Datenbanken</a></li>
                </div>
                <div class="hovernav">
                    <li><a href="https://zeldacovers.github.io/dokumentation101/">HTML/CSS</a></li>
                </div>
            </ul>
        </nav>
    </header>
    <div id="flex">
        <main>
            <p style="text-align: justify;">&nbsp;</p>
            <div class="style1">
                <h1 style="text-align: justify;">Rationale Datenbanken;</h1>
                <hr>
                <p style="text-align: justify;">Eine relationale Datenbank kann man sich als eine Sammlung von Tabellen (den
                    Relationen) vorstellen, in welchen Datens&auml;tze abgespeichert sind. Jede Zeile (Tupel) in einer Tabelle
                    ist ein Datensatz (record). Jedes Tupel besteht aus einer Reihe von Attributwerten (Attribute = Eigenschaften),
                    den Spalten der Tabelle. Relation heisst Beziehung. Das bedeutet das Relationales Datenbankmodell unter
                    anderem auch auf Beziehungen aufbaut mit anderen Tabellen in einer Datenbank.</p>
            </div>
            <div class="style1">
                <h1 style="text-align: justify;">Datenbanken Modellieren.</h1>
                <hr>
                <p style="text-align: justify;">Eine Datenbank kann man gut oder schlecht modellieren, man spricht von einer
                    guten Modellierung, wenn eine Datenbank eine: &nbsp;Redundanzfreie Datenspeicherung und hohe Datenkonsistenz
                    hat. Eine redundanzfreie Datenspeicherung liegt dann vor, wenn jede Information in einer Datenbank genau
                    einmal vorkommt. Des Weiteren muss eine hohe Datenkonsistenz verfolgt werden, so dass Daten eindeutige
                    Informationen darstellen. Es gibt ein Paar neue Begriffe welche man zum Datenbank Modellieren kennen
                    sollte:
                </p>
                <table id="tabellemod" data-aos="fade-left">
                    <tbody>
                        <tr>
                            <td class="begriff" width="353">
                                <h2>Begriff</h2>
                            </td>
                            <td class="erklarung" width="354">
                                <h2>Erkl&auml;rung</h2>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Entit&auml;t (Tabellenname):</p>
                            </td>
                            <td width="354">
                                <p>Eine Entit&auml;t stellt ein Objekt eines Themenkreises dar, welches Elemente mit gleichen
                                    Merkmalen beinhaltet. Beispiele f&uuml;r m&ouml;gliche Entit&auml;ten sind: Firma, Student,
                                    Kurs und Professor.</p>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Entit&auml;tsmenge (Alle Datens&auml;tze einer Entit&auml;t):</p>
                            </td>
                            <td width="354">
                                <p>Eine Entit&auml;tsmenge repr&auml;sentiert alle Datens&auml;tze, die zu einer Entit&auml;t
                                    geh&ouml;ren.
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Relation (Tabelle):</p>
                            </td>
                            <td width="354">
                                <p>Eine Relation umfasst eine Entit&auml;t inklusive der dazugeh&ouml;rigen Entit&auml;tsmenge.
                                    Eine komplette Relation besteht aus einer Entit&auml;tsbezeichnung, deren Attributen
                                    und Tupeln.</p>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Tupel (Datensatz):</p>
                            </td>
                            <td width="354">
                                <p>Ein Tupel repr&auml;sentiert alle Merkmalswerte einer Entit&auml;t einer Entit&auml;tsmenge.
                                    Alle Tupel einer Entit&auml;t bilden die Entit&auml;tsmenge.</p>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Attribut (Spaltenname):</p>
                            </td>
                            <td width="354">
                                <p>Ein Attribut beschreibt genau ein Merkmal eines Tupels in einer Entit&auml;tsmenge, zum
                                    Beispiel den Namen eines Kunden.</p>
                            </td>
                        </tr>
                        <tr>
                            <td width="353">
                                <p>Attributwert (Wert)</p>
                            </td>
                            <td width="354">
                                <p>Der Attributwert repr&auml;sentiert den Wert, den ein Attribut in einem Tupel annehmen
                                    kann, zum Beispiel: Attribut =&gt; Name = &bdquo;Meier&ldquo; &lt;= Attributwert</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p style="text-align: justify;" data-aos="fade-left">Wichtiger Hinweis zum Begriff Relation und Tabelle:</p>
                <p style="text-align: justify;" data-aos="fade-left">Heutzutage werden die Begriffe Relation und Tabelle
                    gleichgesetzt. Das ist leider sehr problematisch, da das Wort &bdquo;Relation&ldquo; im Englischen &bdquo;Beziehung&ldquo;
                    bedeutet. Eine Beziehung hat aber in den Datenbank-Grundlagen eine ganz andere Bedeutung und sagt aus,
                    in welcher Abh&auml;ngigkeit zwei Tabellen zueinanderstehen.</p>
                <p style="text-align: justify;" data-aos="fade-left">Die Grundelemente einer Datenbankmodellierung bilden:
                    Entit&auml;ten, Beziehungen und Attribute. Diese werden grafisch folgenderma&szlig;en dargestellt:</p>
                <img src="bilder/123.jpg" alt="Modell1" data-aos="fade-left">
                <p style="text-align: justify;" data-aos="fade-left">Um was genau es sich bei diesen Elementen handelt, kl&auml;ren
                    die folgenden Punkte:
                </p>
                <ul style="text-align: justify;" data-aos="fade-left">
                    <li>Eine Entit&auml;t ist ein individuell identifizierbares Objekt der Wirklichkeit.</li>
                    <li>Eine Beziehung ist eine Verkn&uuml;pfung / Zusammenhang zwischen zwei oder mehreren Entit&auml;ten.</li>
                    <li>Ein Attribut ist eine Eigenschaft, die im Kontext zu einer Entit&auml;t steht.</li>
                </ul>
                <p style="text-align: justify;" data-aos="fade-left">Das folgende Beispiel eines Datenbank-Modells soll zeigen,
                    wie leicht ein Modell anhand eines realen Beispiels zu erstellen ist:</p>
                <img src="bilder/123123.jpg" alt="Modell2" data-aos="fade-left">
                <p style="text-align: justify;" data-aos="fade-left">Erkl&auml;rung zum Datenbank-Modell: Ein Mitarbeiter
                    hat einen Namen. Ein Projekt hat einen Namen, ein Datum und ein Budget. Ein Mitarbeiter kann mehrere
                    Projekte leiten, aber nur ein Projekt kann von genau einem Mitarbeiter geleitet werden.</p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1 style="text-align: justify;">Prim&auml;rschl&uuml;ssel (primary key)</h1>
                <hr>
                <p style="text-align: justify;">Der Prim&auml;rschl&uuml;ssel kommt in relationalen Datenbanken zum Einsatz
                    und wird zur eindeutigen Identifizierung eines Datensatzes verwendet. In einer normalisierten Datenbank
                    besitzen alle Tabellen einen Prim&auml;rschl&uuml;ssel. Der Wert eines Prim&auml;rschl&uuml;ssels muss
                    in einer Tabelle einmalig sein, da er jeden Datensatz eindeutig kennzeichnet. Des Weiteren wird er h&auml;ufig
                    als Datenbank-Index verwendet, um die Daten auf der Festplatte abzulegen. Es handelt es sich um einen
                    eindeutigen Schl&uuml;ssel, wenn eine Spalte der Tabelle gespeichert wird. Als Spalte kann ein Attribut
                    des Datensatzes verwendet werden, das f&uuml;r jeden Eintrag in der Tabelle einen einmaligen Wert annimmt.
                    Als eindeutiges Prim&auml;rschl&uuml;sselattribut k&ouml;nnte beispielsweise die Sozialversicherungsnummer
                    in einer Mitarbeitertabelle verwendet werden.</p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1 style="text-align: justify;">Fremdschl&uuml;ssel (Foreign Key)</h1>
                <hr>
                <p style="text-align: justify;">Der Fremdschl&uuml;ssel kann Bestandteil einer Tabelle in einer relationalen
                    Datenbank sein. Dabei handelt es sich um eine Schl&uuml;sselspalte, die auf einen Prim&auml;rschl&uuml;ssel
                    einer anderen oder aber derselben Tabelle verweist. Es kann sich dabei um einen einfachen oder zusammengesetzten
                    Schl&uuml;ssel handeln. Das h&auml;ngt davon ab, wie der Prim&auml;rschl&uuml;ssel der referenzierten
                    Tabelle aufgebaut ist.</p>
                <p style="text-align: justify;"><em>was f&uuml;r Fremdschl&uuml;sselarten gibt es?</em></p>
                <p style="text-align: justify;">Aufgrund der referentiellen Integrit&auml;t kann der Fremdschl&uuml;ssel
                    nur Werte annehmen, die in der Referenztabelle vorhanden sind. Zudem kann eine beliebige Anzahl von Datens&auml;tzen
                    den gleichen Fremdschl&uuml;sselwert aufweisen.
                </p>
                <p style="text-align: justify;">Beispiel f&uuml;r den Einsatz eines Fremdschl&uuml;ssels:</p>
                <p style="text-align: justify;">In einer normalisierten Tabelle die Kontakte verwaltet, kann beispielsweise
                    zu einer Person ein Unternehmen referenziert werden. In der Tabelle &bdquo;Ansprechpartner&ldquo; wird
                    &bdquo;Colin Meier&ldquo; und ihre Telefonnummer angelegt. Ihr Unternehmen wird aus der Tabelle &bdquo;Unternehmen&ldquo;
                    referenziert, das w&auml;re dann beispielsweise die &bdquo;ABC GmbH&ldquo;. &Uuml;ber diese Referenz
                    kann bei einer Abfrage die Anschrift und andere Fakten zum Unternehmen aus der Tabelle &bdquo;Unternehmen&ldquo;
                    abgerufen werden.</p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1 style="text-align: justify;">Normalisierung von Datenbanken</h1>
                <hr>
                <p style="text-align: justify;">Unter Normalisierung eines relationalen Datenbankmodells versteht man die
                    Aufteilung von Attributen in mehrere Relationen (Tabellen) mithilfe der Normalisierungsregeln und deren
                    Normalformen, sodass eine Form entsteht, die keine vermeidbaren Redundanzen mehr enth&auml;lt.</p>
                <p style="text-align: justify;"><em>&bdquo;Warum wird eine Normalisierung durchgef&uuml;hrt?&ldquo;</em></p>
                <p style="text-align: justify;">Ziel der Normalisierung ist eine redundanzfreie Datenspeicherung zu erstellen.
                    Redundanzfrei bedeutet, dass Daten entfernt werden k&ouml;nnen, ohne dass es zu Informationsverlusten
                    kommt. Weiterhin soll die Normalisierung Anomalien entfernen. Im Normalisierungsprozess gibt es f&uuml;nf
                    Normalformen, welche im Folgenden genauer erkl&auml;rt werden. In der Datenbankentwicklung ist die Dritte
                    Normalform oft ausreichend, um die perfekte Balance aus Redundanz, Performance und Flexibilit&auml;t
                    f&uuml;r eine Datenbank zu gew&auml;hrleisten. Nat&uuml;rlich gibt es auch Sonderf&auml;lle, z.B. im
                    wissenschaftlichen Bereich, wo eine Datenbank bis zur 5. Normalform normalisiert werden kann bzw. muss.</p>
                <p style="text-align: justify;">Ziele der Datenbank-Normalisierung:</p>
                <ul style="text-align: justify;">
                    <li>Beseitigung von Redundanzen</li>
                    <li>Vermeidung von Anomalien (funktionelle und transitive Abh&auml;ngigkeiten)</li>
                    <li>Erstellung eines klar strukturierten Datenbankmodells</li>
                </ul>
            </div>

            <div class="style1" data-aos="fade-left">
                <h1 style="text-align: justify;">DDL (Data Definition Language)</h1>
                <hr>
                <p style="text-align: justify;">Die Structured Query Language (SQL) zerf&auml;llt grob in zwei Teile:</p>
                <ul style="text-align: justify;">
                    <li>Befehle, mit denen Sie in einem Datenbankmanagementsystem Datenbankobjekte, wie Datenbanken, Tabellen,
                        Spalten und Indizes, erstellen, &auml;ndern bzw. l&ouml;schen, sind in der DDL (Data Definition Language)
                        zusammengefasst. Der DDL widmen wir uns in diesem Abschnitt.</li>
                    <li>Befehle, mit denen Sie Daten in Tabellen einf&uuml;gen, bearbeiten und suchen, geh&ouml;ren zur DML
                        (Data Manipulation Language), mit der wir uns im n&auml;chsten Abschnitt besch&auml;ftigen.</li>
                </ul>
                <ul>
                    <li>In dieser Sprache werden die 3 Befehle, Create Alter und Drop verwendet.</li>
                </ul>
                <p>Hier ein Paar Befehle und Ihre Beschreibung:</p>
                <table data-aos="fade-left">
                    <tbody>
                        <tr>
                            <td class="begriff" width="344">
                                <h2>Befehl</h2>
                            </td>
                            <td class="erklarung" width="345">
                                <h2>Erkl&auml;rung</h2>
                            </td>
                        </tr>
                        <tr>
                            <td width="344">
                                <p class="herv">CREATE TABLE [FIRMA](</p>
                                <p class="herv">[FIRNR] INT NOT NULL PRIMARY KEY</p>
                                <p class="herv">,[FIRUSER] VARCHAR(100) NOT NULL</p>
                                <p class="herv">,[FIRTYP] INT NOT NULL);</p>
                            </td>
                            <td width="345">
                                <p>Dieser Befehl wird genutzt um eine Tabelle zu erstellen. Dazu benutzen wir den Befehl
                                    &laquo;Create&raquo;. &nbsp;Dabei muss man eine neue Tabelle benennen, in unserem Fall
                                    jetzt FIRMA, danach werden die Attribute Einzel angegeben und die dazu passenden Datentypen
                                    vergeben.
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td width="344">
                                <p class="herv">ALTER TABLE [FIRMA] ADD [USTID] VARCHAR(9);</p>
                            </td>
                            <td width="345">
                                <p>Mit einem ALTER Befehl haben wir die M&ouml;glichkeit, eine Tabelle zu ver&auml;ndern
                                    bzw. etwas hinzuzuf&uuml;gen.&nbsp; In diesem Beispiel wird bei der Tabelle Firma noch
                                    das Attribut USTID hinzugef&uuml;gt.</p>
                            </td>
                        </tr>
                        <tr>
                            <td width="344">
                                <p class="herv">DROP TABLE [FIRMA];</p>
                            </td>
                            <td width="345">
                                <p>Als letzten Befehl der DDL haben wir noch den Befehl Drop mit welchem man Tabellen, Attribute
                                    und Datenbanken l&ouml;schen kann. In dieser Beispiel wird die Tabelle FIRMA gel&ouml;scht.</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>DCL (Data Control Language)</h1>
                <hr>
                <p>Die Data Control Language ist daf&uuml;r zust&auml;ndig Rechte zu vergeben oder sie zu entziehen dabei
                    werden wir im Allgemeinen nur zwei Befehle f&uuml;r diese Sprachschicht Benutzen n&auml;mlich:</p>
                <ul>
                    <li>Grant</li>
                    <li>Revoke</li>
                </ul>
                <p>Als kleines Beispiel will ich alle Berechtigungen f&uuml;r die Datenbank 'FIRMA' f&uuml;r den Benutzer
                    'Colin @localhost' erteilen. Deswegen erstelle ich zuerst einen Benutzer mit dem Namen Colin:</p>
                <p class="herv">CREATE USER 'Colin'@'localhost' IDENTIFIED BY '123';</p>
                <p>Dabei ist es wichtig zu wissen, dass zwischen &laquo;IDENTIFIED BY&raquo; das Passwort des jeweiligen
                    Benutzers seinen Platzt findet in unserem Fall 123. Danach kann ich alle Berechtigungen mit der GRANT-Anweisung
                    f&uuml;r den USER Colin auf der Datenbank FIRMA gew&auml;hren mit:</p>
                <p class="herv">GRANT ALL PRIVILEGES ON FIRMA. * TO 'Colin'@'localhost';</p>
                <p>Nun hat der USER Colin alle Berechtigungen f&uuml;r die Tabelle, jedoch wollen wir Vielleicht nicht, dass
                    der USER Colin alle Berechtigungen hat. Es gibt n&auml;mlich noch weitere Berechtigungs-Typen:</p>
                <ul data-aos="fade-left">
                    <li>CREATE: Erlaubt dem Benutzer, neue Datenbanken zu erstellen.</li>
                    <li>DROP: Erlaubt einem Benutzer, Datenbanken zu L&ouml;schen.</li>
                    <li>DELETE: Erlaubt einem Benutzer, einzelne Zeilen in einer Tabelle zu l&ouml;schen.</li>
                    <li>INSERT: Erlaubt einem Benutzer, neue Zeilen in einer Tabelle zu schreiben.</li>
                    <li>SELECT: Leseberechtigung f&uuml;r eine Datenbank oder eine Tabelle</li>
                    <li>UPGRADE: Erlaubnis, eine Zeile zu aktualisieren</li>
                    <li>GRANT OPTION: Erlaubt einen Benutzer weitere Benutzer zu erstellen oder zu l&ouml;schen.</li>
                </ul>
                <p data-aos="fade-left" Zum Schluss werden wir alle &Auml;nderungen mit dem Befehl FLUSH speichern:</p>
                    <p class="herv" data-aos="fade-left">FLUSH PRIVILEGES;</p>
                    <p data-aos="fade-left">Widmen wir uns also noch dem letzten Befehl dieser Sprachschicht n&auml;mlich
                        REVOKE. Denn REVOKE wird verwendet um, Berechtigungen von Benutzerkonten zu entfernen. Also werde
                        ich wieder alle Rechte vom USER Colin entziehen.</p>
                    <p class="herv" data-aos="fade-left">REVOKE ALL PRIVILEGES ON FIRMA. * FROM 'Colin'@'localhost';</p>
                    <p class="herv" data-aos="fade-left">FLUSH PRIVILEGES;</p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>DML (Data Manipulation Language)</h1>
                <hr>
                <p>Unsere Tabellen sind angelegt und warten darauf, mit Daten gef&uuml;ttert bzw. durchsucht zu werden. Lernen
                    Sie im Folgenden, wie das gemacht wird. Fangen wir also am besten damit an, wie eine Datenbank mit Daten
                    gef&uuml;ttert werden kann, dies Machen wir mit dem Befehl INSERT.</p>
                <p class="herv">INSERT INTO &lt;tabelle&gt; (&lt;spalte1&gt;, &lt;spalte2&gt;, ...) VALUES (&lt;wert1&gt;,
                    &lt;wert2&gt;, ...);
                </p>
                <p>Als Beispiel wollen wir einen Datensatz in die Tabelle t_admin einf&uuml;gen:</p>
                <p class="herv">INSERT INTO t_admin (adm_user, adm_pass) VALUES ('Meister', 'geheim');</p>
                <p>Die Zuordnung, welcher Wert in welche Spalte eingef&uuml;gt wird, geschieht &uuml;ber die jeweiligen Positionen
                    innerhalb der Klammern; der erste Wert "`Meister"' wird in die erste Spalte "`adm_user"' eingef&uuml;gt.</p>
                <p data-aos="fade-left">Widmen wir uns noch einen weiteren wichtigen Befehl der DML, n&auml;mlich dem Befehl
                    UPDATE. Mit UPDATE k&ouml;nnen Datens&auml;tze ge&auml;ndert werden, im SET-Teil wird der neue Wert eingetragen.
                    Es sollte unbedingt auf den WHERE-Teil geachtet werden, sonst werden alle Werte &uuml;berschrieben. Die
                    Syntax sieht folgendermassen aus:</p>
                <p class="herv" data-aos="fade-left">UPDATE (Tabellenamen) SET (Attribut)= &rsquo;hallo&rsquo; WHERE x=0;</p>
                <p data-aos="fade-left">Mit DELETE k&ouml;nnen Datens&auml;tze gel&ouml;scht werden, hierbei muss aber auf
                    die WHERE-Bedingungen achten, Definition ansonsten werden alle Datens&auml;tze gel&ouml;scht. Dies ist
                    im ersten Beispiel gemacht.</p>
                <p class="herv" data-aos="fade-left">DELETE FROM (Tabellenamen) ;</p>
                <p class="herv" data-aos="fade-left">DELETE FROM (Tabellenamen) WHERE x=0;</p>
                <p class="herv" data-aos="fade-left">DELETE FROM (Tabellennamen) VALUES (&lsquo;1&rsquo; &lsquo;2&rsquo;)
                    WHERE x=0;</p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>DQL (Data Query Language)</h1>
                <hr>
                <p>Die DQL ist die wichtigste Sprachschicht, denn alle Abfragen und Ausgaben werden mithilfe dieser Schicht
                    gemacht. Die Abfrage funktioniert mit sogenannten Query's, welche immer aus dem SELECT-Befehl bestehen.
                    Der SELECT-Befehl ist auch der einzige in der DQL. Die Query's werden dann an den Server geschickt und
                    dieser gibt dann die gew&uuml;nschten Daten aus, dies ist aber in vielen Situationen nicht so einfach
                    wie es klingt. Der SELECT-Befehl ist immer gefolgt von einem oder mehreren Attributen einer oder mehrerer
                    Entitit&auml;ten. Mit FROM wird dem Server mitgeteilt, von welchen Tabellen die Attribute stammen. Gefolgt
                    wird das FROM von einer oder mehreren WHERE-Bedingungen. Jetzt kann diese Abfrage noch mit einem GROUP
                    BY erg&auml;nzt werden, um die Daten zu b&uuml;ndeln. Wenn jetzt noch eine Bedingung ansteht, kann diese
                    durch ein HAVING erg&auml;nzt werden. Jetzt kann dieses Query nocht mit einem ORDER BY verst&auml;rkt
                    werden, damit diese Ausgabe noch sortiert wird. Ist eine absteigende Sortierung gefragt, kann das ORDER
                    BY noch durch ein DESC unterst&uuml;tzt werden. &Uuml;brigens, Query bedeutet Abfrage und kann jedes
                    Geschlecht der deutschen Sprache annehmen. Hier die Syntax:</p>
                <p class="herv">SELECT (Attribut) FROM (Tabelle) WHERE x=0 GROUP BY (Attribut) HAVING x=1 ORDER BY (Attribut)
                    DESC;
                </p>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>Datentypen</h1>
                <hr>
                <p>Ein Datentyp beschreibt, wie der Inhalt einer Variable aussieht, in diesem Fall wie der Inhalt eines Attributes
                    geschrieben werden muss. Es gibt viele Datentypen, sei es f&uuml;r Zahlen, Strings und Daten wie zum
                    Beispiel f&uuml;r das Datum 12.08.2007. Kurze Nebenbemerkung: jeder Buchstabe ist ein Byte gross. Hier
                    sind die wichtigsten Datentypen aufgelistet:</p>
                <table id="mysql" border="0" width="600" cellspacing="0" cellpadding="0">
                    <tbody>
                        <tr class="row_h">
                            <td class="begriff">
                                <h2>Datentyp</h2>
                            </td>
                            <td class="begriff">
                                <h2>Speicherplatz</h2>
                            </td>
                            <td class="begriff">
                                <h2>Optionen</h2>
                            </td>
                            <td class="begriff">
                                <h2>Beschreibung</h2>
                            </td>
                        </tr>
                        <tr class="row_1">
                            <td>TINYINT</td>
                            <td>1&nbsp;Byte</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Ganzzahlen von 0 bis 255 oder von -128 bis 127.</td>
                        </tr>
                        <tr class="row_2">
                            <td>SMALLINT</td>
                            <td>2&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Ganzzahlen von 0 bis 65.535 oder von -32.768 bis 32.767.</td>
                        </tr>
                        <tr class="row_1">
                            <td>MEDIUMINT</td>
                            <td>3&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Ganzzahlen von 0 bis 16.777.215 oder von -8.388.608 bis 8.388.607.</td>
                        </tr>
                        <tr class="row_2">
                            <td>INT</td>
                            <td>4&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Ganzzahlen von 0 bis ~4,3 Mill. oder von -2.147.483.648 bis 2.147.483.647.</td>
                        </tr>
                        <tr class="row_1">
                            <td>INTEGER</td>
                            <td>4&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Alias f&uuml;r INT.</td>
                        </tr>
                        <tr class="row_2">
                            <td>BIGINT</td>
                            <td>8&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Ganzzahlen von 0 bis 2^64-1 oder von -(2^63) bis (2^63)-1.</td>
                        </tr>
                        <tr class="row_1">
                            <td>FLOAT</td>
                            <td>4&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>,<span
                                    class="help" title="Anzahl der Kommastellen bei einer Dezimalzahl">D</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Flie&szlig;kommazahl mit Vorzeichen. Wertebereich von -(3,402823466&times;10<sup>38</sup>)
                                bis -(1,175494351&times;10<sup>-38</sup>), 0 und 1,175494351&times;10<sup>-38</sup>&nbsp;bis
                                3,402823466&times;10
                                <sup>38</sup>.</td>
                        </tr>
                        <tr class="row_2">
                            <td>DOUBLE</td>
                            <td>8&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>,<span
                                    class="help" title="Anzahl der Kommastellen bei einer Dezimalzahl">D</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Flie&szlig;kommazahl mit Vorzeichen. Wertebereich von -(1,79769&times;10<sup>308</sup>) bis
                                -(2.22507&times;10
                                <sup>-308</sup>), 0 und 2.22507&times;10<sup>-308</sup>bis 1,79769&times;10<sup>308</sup></td>
                        </tr>
                        <tr class="row_1">
                            <td>REAL</td>
                            <td>8&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>,<span
                                    class="help" title="Anzahl der Kommastellen bei einer Dezimalzahl">D</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Alias f&uuml;r DOUBLE.</td>
                        </tr>
                        <tr class="row_2">
                            <td>DECIMAL</td>
                            <td>M+x&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>,<span
                                    class="help" title="Anzahl der Kommastellen bei einer Dezimalzahl">D</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Flie&szlig;kommazahl mit Vorzeichen. Speicherbedarf: x=1 wenn D=0, sonst x=2. Ab MySQL 5.1
                                bin&auml;r gespeichert, zuvor als String.</td>
                        </tr>
                        <tr class="row_1">
                            <td>NUMERIC</td>
                            <td>M+x&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;[(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>,<span
                                    class="help" title="Anzahl der Kommastellen bei einer Dezimalzahl">D</span>)]&nbsp;[<span
                                    class="help" title="UNSIGNED (Zahl ohne Vorzeichen)">U</span>]&nbsp;[<span class="help" title="Zerofill">Z</span>]&nbsp;&nbsp;</td>
                            <td>Alias f&uuml;r DECIMAL.</td>
                        </tr>
                        <tr class="row_2">
                            <td>DATE</td>
                            <td>3&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;-&nbsp;&nbsp;</td>
                            <td>Datum im Format 'YYYY-MM-DD'. Wertebereich von 01.01.1000 bis 31.12.9999.</td>
                        </tr>
                        <tr class="row_1">
                            <td>DATETIME</td>
                            <td>8&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;-&nbsp;&nbsp;</td>
                            <td>Datumsangabe im Format 'YYYY-MM-DD hh:mm:ss'. Wertebereich entspricht DATE.</td>
                        </tr>
                        <tr class="row_2">
                            <td>TIMESTAMP</td>
                            <td>4&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;-&nbsp;&nbsp;</td>
                            <td>Zeitstempel. Wertebereich: 1.1.1970 bis 19.01.2038. Das Format variiert in den MySQL-Versionen.</td>
                        </tr>
                        <tr class="row_1">
                            <td>TIME</td>
                            <td>3&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;-&nbsp;&nbsp;</td>
                            <td>Zeit zwischen -838:59:59 und 839:59:59. Ausgabe: hh:mm:ss.</td>
                        </tr>
                        <tr class="row_2">
                            <td>YEAR</td>
                            <td>1&nbsp;Byte</td>
                            <td>&nbsp;&nbsp;[(2|4)]&nbsp;&nbsp;</td>
                            <td>Jahr zwischen 1901 bis 2155 bei (4) und zwischen 1970 bis 2069 bei (2).</td>
                        </tr>
                        <tr class="row_1">
                            <td>CHAR</td>
                            <td>M&nbsp;Byte(s)</td>
                            <td>&nbsp;&nbsp;(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)&nbsp;[<span
                                    class="help" title="Attribut f&uuml;r die Sortierung">BINARY</span>]&nbsp;&nbsp;</td>
                            <td>Zeichenkette fester L&auml;nge M. Wertebereich f&uuml;r M: 0 bis 255.</td>
                        </tr>
                        <tr class="row_2">
                            <td>VARCHAR</td>
                            <td>L+1&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)&nbsp;[<span
                                    class="help" title="Attribut f&uuml;r die Sortierung">BINARY</span>]&nbsp;&nbsp;</td>
                            <td>Zeichenkette variabler L&auml;nge, Maximum ist M. Wertebereich f&uuml;r M: 0 bis 255.</td>
                        </tr>
                        <tr class="row_1">
                            <td>BINARY</td>
                            <td>M&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)&nbsp;&nbsp;</td>
                            <td>Zum Speichern bin&auml;rer Strings, unabh&auml;ngig vom Zeichensatz. Wertebereich f&uuml;r
                                M: 0 bis 255. Weiterer Typ: VARBINARY</td>
                        </tr>
                        <tr class="row_2">
                            <td>BLOB</td>
                            <td>L+2&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)&nbsp;&nbsp;</td>
                            <td>Bin&auml;res Objekt mit variablen Daten. Weitere Typen: TINYBLOB, MEDIUMBLOB und LONGBLOB.
                                M ist ab Version 4.1 definierbar.</td>
                        </tr>
                        <tr class="row_1">
                            <td>TEXT</td>
                            <td>L+2&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;(<span class="help" title="maximale Anzahl der gezeigten Stellen">M</span>)&nbsp;&nbsp;</td>
                            <td>Wie BLOB. Ignoriert beim Sortieren &amp; Vergleichen Gro&szlig;- und Kleinschreibung. Weitere
                                Typen: TINYTEXT, MEDIUMTEXT, LONGTEXT. M ist ab Version 4.1 definierbar.</td>
                        </tr>
                        <tr class="row_2">
                            <td>ENUM</td>
                            <td>1&nbsp;oder&nbsp;2&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;('val1',&nbsp;'val2',&nbsp;...)&nbsp;&nbsp;</td>
                            <td>Liste von Werten (val1, val2, ...). 65.535 eineindeutige Elemente sind maximal m&ouml;glich.</td>
                        </tr>
                        <tr class="row_1">
                            <td>SET</td>
                            <td>x&nbsp;Bytes</td>
                            <td>&nbsp;&nbsp;('val1',&nbsp;'val2',&nbsp;...)&nbsp;&nbsp;</td>
                            <td>String-Objekt mit verschiedenen Variablen. 64 sind maximal m&ouml;glich. Speicherbedarf:
                                x ist 1, 2, 3, 4 oder 8.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>Funktionen und Operatoren</h1>
                <hr>
                <p>&nbsp;Mit SQL Funktionen k&ouml;nnen bestimmte Werte einer Spalte berechnet oder bestimmte Werte mittels
                    der SQL Funktionen im Nachhinein manipuliert werden.</p>
                <p><em>&bdquo;Welche SQL Funktionen gibt es?&ldquo;</em></p>
                <p>Es existieren zwei Arten von SQL Funktionen: SQL Aggregat Funktionen und SQL Skalar Funktionen. Mit SQL
                    Aggregat Funktionen, wie z.B. SUM() oder AVG(), k&ouml;nnen Tabellenspalten auf ihre Werte zusammengefasst
                    und berechnet werden. Mit SQL Skalar Funktionen, wie z.B. LEN() oder Round(), liefern Einzelwerte auf
                    Basis ihrer Inputvariable zur&uuml;ck. Alle SQL Funktionen k&ouml;nnen sowohl in der Datenbanksprache
                    T-SQL von Microsoft als auch in der Datenbanksprache PL/SQL von ORACLEverwendet werden und z&auml;hlen
                    damit zu den grundlegenden SQL Funktionen. Da es mehrere Funktionen gibt, verweise ich auf diese <a href="http://www.datenbanken-verstehen.de/sql-funktionen/"
                        class="link">Seite</a>
                    hier, denn dort wird jede Funktion super erkl&auml;rt. Unten finden sie noch die Operatoren welche bei Funktionen gebraucht
                    werden.
                </p>
                <table>
                    <tbody>
                        <tr>
                            <td class="begriff">
                                <h2><strong>Operator</strong></h2>
                            </td>
                            <td class="begriff">
                                <h2><strong>Erl&auml;uterung</strong></h2>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>&gt;&nbsp;</p>
                            </td>
                            <td>
                                <p>Gr&ouml;&szlig;er als (geht auch mit gr&ouml;&szlig;er-gleich, also&nbsp;&gt;=)</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>&lt;&nbsp;</p>
                            </td>
                            <td>
                                <p>Kleiner als (geht auch mit kleiner-gleich, also&nbsp;&lt;=)</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>=</p>
                            </td>
                            <td>
                                <p>Gleich</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>!=</p>
                            </td>
                            <td>
                                <p>Ungleich</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>BETWEEN</p>
                            </td>
                            <td>
                                <p>Ermittelt Minimal- und Maximalwert</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>LIKE</p>
                            </td>
                            <td>
                                <p>Zeichenkettenvergleich</p>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <p>IN</p>
                            </td>
                            <td>
                                <p>Array-Vergleich ( analog zu&nbsp;in_array&nbsp;von PHP)</p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="style1" data-aos="fade-left">
                <h1>Joins</h1>
                <hr>
                <p>Mit einem Join lassen sich Werte aus mehreren SQL Tabellen kombinieren. Statt nun mehrere SELECT Abfragen
                    an verschiedenen Tabellen vorzunehmen, kann man einen einzelnen SQL Befehl eingeben um mehrere Tabellen
                    gleichzeitig abzufragen. Damit ein solcher JOIN funktioniert m&uuml;ssen die Tabellen, welche verkn&uuml;pft
                    werden, &uuml;ber eine gemeinsame Spalte mittels Foreign Key und Primary Key verbunden werden. In MySQL
                    stehen insgesamt vier verschiedene JOIN-Typen zur Verf&uuml;gung, und zwar der INNER JOIN, LEFT JOIN,
                    RIGHT JOIN und der FULL JOIN. Der Syntax eines solchen JOINs sieht wie folgt aus:</p>
                <p class="herv">
                    Select * From tabelle1 JOIN tabelle2 ON tabelle1.PK = tabelle2.FK JOIN tabelle3 ON tabelle1.PK = tabelle3.FK WHERE bedingung;
                </p>
                <p>Der Syntax des INNER JOINS ist gleich dem des LEFT INNER JOINS, nur dass anstelle von LEFT INNER JOIN
                    nur JOIN als JOIN-Typ geschrieben wird. Hierbei wird die Schnittmenge der beiden selektierten Tabellen
                    ausgegeben, welche der unteren WHERE Bedingung entsprechen.</p>
                <img class="innerjoin" src="https://janikwibilea.github.io/lerndoku_105/images/inner%20join%20kreis.PNG" alt="png">
                <p data-aos="fade-left">In diesem Beispiel werden die Produkte ausgegeben, welche noch nie bestellt wurden. Um einen solchen JOIN
                    zu erstellen müssen wir die Tabelle "products" und "orders" miteinander verknüpfen. Da wir nur die Produkte
                    ausgeben möchten die noch nie bestellt wurden eignet sich ein LEFT INNER JOIN am besten. Der nächste
                    Schritt ist es zu bestimmen auf (ON) welchen Spalten sie sich gegenseitig joinen sollen, in diesem Fall
                    ist p.id als PRIMARY KEY und orders.product_id als FOREIGN KEY bestimmt. Am Schluss setzt man die Bedingung
                    mit WHERE welche bestimmt das die Spalte orders.id leer sein muss.</p>
                <img class="innerjoin" src="https://janikwibilea.github.io/lerndoku_105/images/left%20inner%20join%20kreis.PNG" alt="png" data-aos="fade-left">
                <p data-aos="fade-left">Der LEFT bzw. RIGHT OUTER JOIN ist bis auf die fehlende WHERE Bedingung gleich aufgebaut wie der LEFT/RIGHT
                    INNER JOIN. </p>
                <img class="innerjoin" src="https://janikwibilea.github.io/lerndoku_105/images/left%20join%20kreis.PNG" alt="png" data-aos="fade-left">
                <p data-aos="fade-left">Der FULL OUTER JOIN wird nur in den seltensten Fällen verwendet, weil er alle Datensätze ausgibt die zwischen
                    den beiden verknüpften Tabellen gleich. Dies führt dazu das oftmals extrem viele Datensätze augegeben
                    werden.</p>
                    <img class="innerjoin" src="https://janikwibilea.github.io/lerndoku_105/images/full%20auter%20join.PNG" alt="png" data-aos="fade-left">
            </div>

        </main>
    </div>
</body>

</html>
<style type="text/css">
</style>
<script type="text/javascript">
    AOS.init({
        duration: 1200,
    })


</script>